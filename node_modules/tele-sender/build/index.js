"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Telegram_ParseModes = void 0;
const https_1 = __importDefault(require("https"));
var Telegram_ParseModes;
(function (Telegram_ParseModes) {
    Telegram_ParseModes[Telegram_ParseModes["MarkdownV2"] = 0] = "MarkdownV2";
    Telegram_ParseModes[Telegram_ParseModes["HTML"] = 1] = "HTML";
})(Telegram_ParseModes = exports.Telegram_ParseModes || (exports.Telegram_ParseModes = {}));
class Telegram {
    api;
    updates;
    constructor(api) {
        this.api = api;
    }
    async send(id, text, parseMode) {
        return (await this.request('/sendMessage', {
            chat_id: id,
            text: text,
            parse_mode: parseMode === undefined ? undefined : Telegram_ParseModes[parseMode],
        })).ok;
    }
    async findID() {
        const updates = await this.request('/getUpdates', this.updates === undefined ? undefined : { offset: this.updates });
        const users = {};
        const result = updates.result;
        if (result) {
            const resultLength = result.length;
            for (let i = 0; i < resultLength; i++) {
                const item = result[i];
                if (!item.message.from.is_bot) {
                    users[item.message.from.username] = item.message.from.id;
                }
            }
            this.updates = result[resultLength - 1].update_id + 1;
        }
        return users;
    }
    request(path, data) {
        return new Promise((resolve, reject) => {
            const req = https_1.default.request('https://api.telegram.org/bot' + this.api + path, {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                },
            }, (res) => {
                let result = '';
                res
                    .setEncoding('utf-8')
                    .on('data', (chunk) => {
                    result += chunk;
                })
                    .on('end', () => {
                    resolve(JSON.parse(result));
                });
            }).on('error', reject);
            if (data) {
                req.write(JSON.stringify(data));
            }
            req.end();
        });
    }
}
exports.default = Telegram;
//# sourceMappingURL=index.js.map